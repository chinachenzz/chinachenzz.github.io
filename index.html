<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/26/C-笔试算法题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/26/C-笔试算法题/" itemprop="url">C++笔试算法题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-26T12:17:46+08:00">
                2019-09-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>第一题</p>
<p>重写setprecision函数</p>
<p>第二题</p>
<p>提取文本中的数字</p>
<p>第三题</p>
<p>Vector找最大值和最小值</p>
<p>vetor<int> tmp;</int></p>
<p>找最大值的位置</p>
<p>auto Max_position=max_element(tmp.begin(),tmp.end());</p>
<p>找最大值(对迭代器进行解引用)</p>
<p>int Max_value=*max_element(tmp.begin(),tmp.end())；</p>
<p>第四题</p>
<p>顺时针打印矩阵</p>
<p> 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵，则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<p>​                                                                                                </p>
<h4 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a><strong>2.思路</strong></h4><p>​      把矩阵看成由若干个顺时针方向的圈组成，循环打印矩阵中的每个圈，每次循环打印一个圈。打印一圈通常分为四步，第一步从左到右打印一行；第二步从上到下打印一列；第三步从右到左打印一行；第四步从下到上打印一列。设置四个变量left，right，top，btm，用于表示圈的方位，每一步根据起始坐标和终止坐标循环打印。</p>
<p><strong>注意</strong>：最后一圈有可能不需要四步，有可能只有一行，只有一列，只有一个数字，因此我们要仔细分析打印每一步的前提条件：</p>
<ul>
<li>打印第一步，第一步总是需要的。</li>
</ul>
<ul>
<li><img src="https://images2018.cnblogs.com/blog/1307402/201803/1307402-20180321153822657-591329115.png" alt="img"></li>
<li>打印第二步的前提条件是(top&lt;btm)</li>
</ul>
<p><img src="https://images2018.cnblogs.com/blog/1307402/201803/1307402-20180321153824388-2135481654.png" alt="image_thumb[20]"></p>
<ul>
<li>打印第三步的前提条件是(top&lt;btm &amp;&amp; left&lt;right)</li>
</ul>
<p><img src="https://images2018.cnblogs.com/blog/1307402/201803/1307402-20180321153825500-1956530299.png" alt="image_thumb[21]"></p>
<ul>
<li>打印第四步的前提条件是(top+1&lt;btm&amp;&amp;left&lt;right)</li>
</ul>
<p>class Solution {<img src="https://images2018.cnblogs.com/blog/1307402/201803/1307402-20180321153826627-1772650522.png" alt="image_thumb[22]"><br>public:<br>    vector<int> printMatrix(vector&lt;vector<int> &gt; matrix) {<br>        // 存储结果<br>        vector<int> result;<br>        // 边界条件<br>        if(matrix.empty())<br>            return result;<br>        // 二维矩阵行列<br>        int rows = matrix.size();<br>        int cols = matrix[0].size();<br>        // 圈的四个角标<br>        int left = 0;<br>        int right = cols-1;<br>        int top = 0;<br>        int btm = rows-1;<br>        // 循环打印圈<br>        while(left &lt;= right &amp;&amp; top &lt;= btm){             // 循环条件：<br>            // 圈的第一步<br>            for(int i=left;i&lt;=right;++i)                // 第一步循环条件<br>                result.push_back(matrix[top][i]);       // 第一步坐标<br>            // 圈的第二步<br>            if(top&lt;btm)                                 // 第二步边界条件<br>                for(int i=top+1;i&lt;=btm;++i)             // 第二步循环条件<br>                    result.push_back(matrix[i][right]); // 第二步坐标<br>            // 圈的第三步<br>            if(top&lt;btm &amp;&amp; left&lt;right)                   // 第三步边界条件<br>                for(int i=right-1;i&gt;=left;–i)          // 第三步循环条件<br>                    result.push_back(matrix[btm][i]);   // 第三步坐标<br>            // 圈的第四步<br>            if(top+1&lt;btm &amp;&amp; left&lt;right)                 // 第四步边界条件<br>                for(int i=btm-1;i&gt;=top+1;–i)           // 第四步循环条件<br>                    result.push_back(matrix[i][left]);  // 第四步坐标</int></int></int></p>
<pre><code>        ++left;--right;++top;--btm;
    }
    return result;
}</code></pre><p>};</p>
<p>题目描述：输入一个矩阵，按照从外向里以顺时针打印出每一个数字，例如：输入如下矩阵，则依次打印出的数字为：1、2、3、4、8、12、16、15、14、13、9、5、6、7、11、10.</p>
<p>思路分析：当我们顺时针打印该矩阵时，每一圈的起始位置是左上角的元素，并且每一圈左上角元素都有一个共同点：它的行和列所对应的的下标都是相同的。因此不难想到，该矩阵打印结束的条件就是左上角的元素下标走到了该矩阵行和列的一半时该矩阵也就打印结束了。因为矩阵也是用下标来确定某个数字的，所以这里就是：4&gt;1*2</p>
<p>可是，我们上面给的矩阵很特殊，并且行和列的都是偶数个，不具有说服力，我们还需要考虑考虑其他的情况，以验证我们得到的结论是否具有普遍性。例如：一个7<em>7的矩阵，将该矩阵打印结束的条件就是：左上角的元素为（3,3）时，也就是说7&gt;3</em>2</p>
<p>这里乘二也是因为矩阵每打印完一圈，对应的下三角部分已经打印过了。矩阵打印的大体框架我们已经做好了，现在还有一个问题，就是如何打印矩阵的每一圈</p>
<p>如上图，矩阵打印一圈需要四步，这个是一般情况，当我们的矩阵是行大于列、列大于行的时候可能不需要四步，就可以打印结束，如下图：</p>
<p>从上图不难看出，无论是一个怎样的矩阵，它都会进行第一步，并且如果打印一个矩阵它进行了第三步，那么一定走了一二步，也就是说后面的每一步是建立在前面步的基础之上的，我们总结一下打印每一圈。</p>
<p>（1）从左往右：肯定有；</p>
<p>（2）从上到下：矩阵行数至少为2，即：终止行号必须大于起始行号（这里不可以等于哦，否则会产生矩阵右上角的元素重复多打印一次）；</p>
<p>（3）从右往左：矩阵至少为两行两列，即：终止列号必须大于起始列号，并且终止行号必须大于起始行号（同样，不可以等于，否则矩阵右下角的元素会多打印一次）；</p>
<p>（4）从下到上：矩阵至少为三行两列，即：终止行号必须比起始行号大2，并且终止列号必须大于起始列号（同样，不可以等于，否则会出现左下角和右上角元素多打印一次）<br>————————————————<br>void PrintOneCircle(vector&lt;vector<int>&gt; matrix, int rows, int cols, int start, vector<int>&amp; v)<br>{<br>    if (matrix.empty())<br>        return;</int></int></p>
<pre><code>int endX = cols - 1 - start;//列
int endY = rows - 1 - start;//行

//从左往右打印
for (int i = start; i &lt;= endX; i++)
{
    v.push_back(matrix[start][i]);
}
//从上到下打印
if (start&lt;endY)
for (int i = start + 1; i &lt;= endY; i++)
{
    v.push_back(matrix[i][endX]);
}
//从右往左打印
if (start&lt;endX&amp;&amp;start&lt;endY)
for (int i = endX-1; i &gt;= start; i--)
{
    v.push_back(matrix[endY][i]);
}
//从下到上打印
if (start&lt;endX&amp;&amp;start&lt;endY - 1)
for (int i = endY - 1; i &gt;= start + 1; i--)
{
    v.push_back(matrix[i][start]);
}</code></pre><p>}<br>vector<int> printMatrix(vector&lt;vector<int> &gt; matrix)<br>{<br>    vector<int> v;<br>    if (matrix.size() == 0)<br>        return v;</int></int></int></p>
<pre><code>int rows = matrix.size();
int cols = matrix[0].size();

int start = 0;
while (rows&gt;2 * start&amp;&amp;cols&gt;2 * start)
{
    PrintOneCircle(matrix, rows, cols, start, v);
    start++;
}

return v;</code></pre><p>}</p>
<p>————————————————<br>版权声明：本文为CSDN博主「cherrydreamsover」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/cherrydreamsover/article/details/80518759" target="_blank" rel="noopener">https://blog.csdn.net/cherrydreamsover/article/details/80518759</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/26/C-中实现进程同步的四种方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/26/C-中实现进程同步的四种方式/" itemprop="url">C++中实现进程同步的四种方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-26T12:11:44+08:00">
                2019-09-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="为什么要进行线程同步？"><a href="#为什么要进行线程同步？" class="headerlink" title="为什么要进行线程同步？"></a>为什么要进行线程同步？</h3><p>在程序中使用多线程时，一般很少有多个线程能在其生命期内进行完全独立的操作。更多的情况是一些线程进行某些处理操作，而其他的线程必须对其处理结果进行了解。正常情况下对这种处理结果的了解应当在其处理任务完成后进行。<br>　　如果不采取适当的措施，其他线程往往会在线程处理任务结束前就去访问处理结果，这就很有可能得到有关处理结果的错误了解。例如，多个线程同时访问同一个全局变量，如果都是读取操作，则不会出现问题。如果一个线程负责改变此变量的值，而其他线程负责同时读取变量内容，则不能保证读取到的数据是经过写线程修改后的。<br>　　为了确保读线程读取到的是经过修改的变量，就必须在向变量写入数据时禁止其他线程对其的任何访问，直至赋值过程结束后再解除对其他线程的访问限制。这种保证线程能了解其他线程任务处理结束后的处理结果而采取的保护措施即为线程同步。</p>
<p>代码示例：<br>两个线程同时对一个全局变量进行加操作，演示了多线程资源访问冲突的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`#include &quot;stdafx.h&quot;``#include&lt;windows.h&gt;``#include&lt;iostream&gt;``using` `namespace` `std;` `int` `number = 1;` `unsigned ``long` `__stdcall ThreadProc1(``void``* lp)``&#123;``    ``while` `(number &lt; 100)``    ``&#123;``        ``cout &lt;&lt; ``&quot;thread 1 :&quot;``&lt;&lt;number &lt;&lt; endl;``        ``++number;``        ``_sleep(100);``    ``&#125;` `    ``return` `0;``&#125;` `unsigned ``long` `__stdcall ThreadProc2(``void``* lp)``&#123;``    ``while` `(number &lt; 100)``    ``&#123;``        ``cout &lt;&lt; ``&quot;thread 2 :&quot;``&lt;&lt;number &lt;&lt; endl;``        ``++number;``        ``_sleep(100);``    ``&#125;` `    ``return` `0;``&#125;` `int` `main()``&#123;``    ``CreateThread(NULL, 0, ThreadProc1, NULL, 0, NULL);``    ``CreateThread(NULL, 0, ThreadProc2, NULL, 0, NULL);` `    ``Sleep(10*1000);` `    ``system``(``&quot;pause&quot;``);``    ``return` `0;``&#125;　　`</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="https://img-blog.csdn.net/20170705222827993?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc19saXNoZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>可以看到有时两个线程计算的值相同，不是我们想要的结果。</p>
<h2 id="关于线程同步"><a href="#关于线程同步" class="headerlink" title="关于线程同步"></a>关于线程同步</h2><p>线程之间通信的两个基本问题是互斥和同步。</p>
<ul>
<li><em>线程同步</em>是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。</li>
<li><em>线程互斥</em>是指对于共享的操作系统资源（指的是广义的”资源”，而不是Windows的.res文件，譬如全局变量就是一种共享资源），在各线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。</li>
</ul>
<p>线程互斥是一种特殊的线程同步。实际上，互斥和同步对应着线程间通信发生的两种情况：</p>
<ul>
<li>当有多个线程访问共享资源而不使资源被破坏时；</li>
<li>当一个线程需要将某个任务已经完成的情况通知另外一个或多个线程时。</li>
</ul>
<p>从大的方面讲，线程的同步可分用户模式的线程同步和内核对象的线程同步两大类。</p>
<ul>
<li>用户模式中线程的同步方法主要有原子访问和临界区等方法。其特点是同步速度特别快，适合于对线程运行速度有严格要求的场合。</li>
<li>内核对象的线程同步则主要由事件、等待定时器、信号量以及信号灯等内核对象构成。由于这种同步机制使用了内核对象，使用时必须将线程从用户模式切换到内核模式，而这种转换一般要耗费近千个CPU周期，因此同步速度较慢，但在适用性上却要远优于用户模式的线程同步方式。</li>
</ul>
<p>在WIN32中，同步机制主要有以下几种：<br>（1）事件(Event);<br>（2）信号量(semaphore);<br>（3）互斥量(mutex);<br>（4）临界区(Critical section)。</p>
<h2 id="Win32中的四种同步方式"><a href="#Win32中的四种同步方式" class="headerlink" title="Win32中的四种同步方式"></a>Win32中的四种同步方式</h2><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>临界区（Critical Section）是一段独占对某些共享资源访问的代码，在任意时刻只允许一个线程对共享资源进行访问。如果有多个线程试图同时访问临界区，那么在有一个线程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操作共享资源的目的。</p>
<p>临界区在使用时以CRITICAL_SECTION结构对象保护共享资源，并分别用EnterCriticalSection（）和LeaveCriticalSection（）函数去标识和释放一个临界区。所用到的CRITICAL_SECTION结构对象必须经过InitializeCriticalSection（）的初始化后才能使用，而且必须确保所有线程中的任何试图访问此共享资源的代码都处在此临界区的保护之下。否则临界区将不会起到应有的作用，共享资源依然有被破坏的可能。</p>
<p>代码示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`#include &quot;stdafx.h&quot;``#include&lt;windows.h&gt;``#include&lt;iostream&gt;``using` `namespace` `std;` `int` `number = 1; ``//定义全局变量``CRITICAL_SECTION Critical;      ``//定义临界区句柄` `unsigned ``long` `__stdcall ThreadProc1(``void``* lp)``&#123;``    ``while` `(number &lt; 100)``    ``&#123;``        ``EnterCriticalSection(&amp;Critical);``        ``cout &lt;&lt; ``&quot;thread 1 :&quot;``&lt;&lt;number &lt;&lt; endl;``        ``++number;``        ``_sleep(100);``        ``LeaveCriticalSection(&amp;Critical);``    ``&#125;` `    ``return` `0;``&#125;` `unsigned ``long` `__stdcall ThreadProc2(``void``* lp)``&#123;``    ``while` `(number &lt; 100)``    ``&#123;``        ``EnterCriticalSection(&amp;Critical);``        ``cout &lt;&lt; ``&quot;thread 2 :&quot;``&lt;&lt;number &lt;&lt; endl;``        ``++number;``        ``_sleep(100);``        ``LeaveCriticalSection(&amp;Critical);``    ``&#125;` `    ``return` `0;``&#125;` `int` `main()``&#123;``    ``InitializeCriticalSection(&amp;Critical);   ``//初始化临界区对象` `    ``CreateThread(NULL, 0, ThreadProc1, NULL, 0, NULL);``    ``CreateThread(NULL, 0, ThreadProc2, NULL, 0, NULL);` `    ``Sleep(10*1000);` `    ``system``(``&quot;pause&quot;``);``    ``return` `0;``&#125;`</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="https://img-blog.csdn.net/20170705224826272?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc19saXNoZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>可以看到，也实现了有序输出，实现了线程同步。</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>事件(Event)是WIN32提供的最灵活的线程间同步方式，事件可以处于激发状态(signaled or true)或未激发状态(unsignal or false)。根据状态变迁方式的不同，事件可分为两类：<br>（1）手动设置：这种对象只可能用程序手动设置，在需要该事件或者事件发生时，采用SetEvent及ResetEvent来进行设置。<br>（2）自动恢复：一旦事件发生并被处理后，自动恢复到没有事件状态，不需要再次设置。</p>
<p>使用”事件”机制应注意以下事项：<br>（1）如果跨进程访问事件，必须对事件命名，在对事件命名的时候，要注意不要与系统命名空间中的其它全局命名对象冲突；<br>（2）事件是否要自动恢复；<br>（3）事件的初始状态设置。</p>
<p>由于event对象属于内核对象，故进程B可以调用OpenEvent函数通过对象的名字获得进程A中event对象的句柄，然后将这个句柄用于ResetEvent、SetEvent和WaitForMultipleObjects等函数中。此法可以实现一个进程的线程控制另一进程中线程的运行，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`HANDLE` `hEvent=OpenEvent(EVENT_ALL_ACCESS,``true``,``&quot;MyEvent&quot;``); ``ResetEvent(hEvent);`</span><br></pre></td></tr></table></figure>

<p>代码示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`#include &quot;stdafx.h&quot;``#include&lt;windows.h&gt;``#include&lt;iostream&gt;``using` `namespace` `std;` `int` `number = 1; ``//定义全局变量``HANDLE` `hEvent;  ``//定义事件句柄` `unsigned ``long` `__stdcall ThreadProc1(``void``* lp)``&#123;``    ``while` `(number &lt; 100)``    ``&#123;``        ``WaitForSingleObject(hEvent, INFINITE);  ``//等待对象为有信号状态``        ``cout &lt;&lt; ``&quot;thread 1 :&quot;``&lt;&lt;number &lt;&lt; endl;``        ``++number;``        ``_sleep(100);``        ``SetEvent(hEvent);``    ``&#125;` `    ``return` `0;``&#125;` `unsigned ``long` `__stdcall ThreadProc2(``void``* lp)``&#123;``    ``while` `(number &lt; 100)``    ``&#123;``        ``WaitForSingleObject(hEvent, INFINITE);  ``//等待对象为有信号状态``        ``cout &lt;&lt; ``&quot;thread 2 :&quot;``&lt;&lt;number &lt;&lt; endl;``        ``++number;``        ``_sleep(100);``        ``SetEvent(hEvent);``    ``&#125;` `    ``return` `0;``&#125;` `int` `main()``&#123;``    ``CreateThread(NULL, 0, ThreadProc1, NULL, 0, NULL);``    ``CreateThread(NULL, 0, ThreadProc2, NULL, 0, NULL);``    ``hEvent = CreateEvent(NULL, FALSE, TRUE, ``&quot;event&quot;``);` `    ``Sleep(10*1000);` `    ``system``(``&quot;pause&quot;``);``    ``return` `0;``&#125;`</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="https://img-blog.csdn.net/20170705223744494?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc19saXNoZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>可以看到，实现了有序输出，实现了线程同步。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量是维护0到指定最大值之间的同步对象。信号量状态在其计数大于0时是有信号的，而其计数是0时是无信号的。信号量对象在控制上可以支持有限数量共享资源的访问。</p>
<p>信号量的特点和用途可用下列几句话定义：<br>（1）如果当前资源的数量大于0，则信号量有效；<br>（2）如果当前资源数量是0，则信号量无效；<br>（3）系统决不允许当前资源的数量为负值；<br>（4）当前资源数量决不能大于最大资源数量。</p>
<h4 id="创建信号量"><a href="#创建信号量" class="headerlink" title="创建信号量"></a>创建信号量</h4><p>函数原型为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`HANDLE` `CreateSemaphore (``  ``　PSECURITY_ATTRIBUTE psa, ``//信号量的安全属性``　  ``LONG` `lInitialCount, ``//开始时可供使用的资源数``　  ``LONG` `lMaximumCount, ``//最大资源数``   ``PCTSTR` `pszName);     ``//信号量的名称`</span><br></pre></td></tr></table></figure>

<p>　　</p>
<h4 id="释放信号量"><a href="#释放信号量" class="headerlink" title="释放信号量"></a>释放信号量</h4><p>通过调用ReleaseSemaphore函数，线程就能够对信标的当前资源数量进行递增，该函数原型为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`BOOL` `WINAPI ReleaseSemaphore(``  ``　``HANDLE` `hSemaphore,   ``//要增加的信号量句柄``  ``　``LONG` `lReleaseCount, ``//信号量的当前资源数增加lReleaseCount``  ``　``LPLONG` `lpPreviousCount  ``//增加前的数值返回``   ``);`</span><br></pre></td></tr></table></figure>

<h4 id="打开信号量"><a href="#打开信号量" class="headerlink" title="打开信号量　"></a>打开信号量　</h4><p>和其他核心对象一样，信号量也可以通过名字跨进程访问，打开信号量的API为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`HANDLE` `OpenSemaphore (``  ``　``DWORD` `fdwAccess,      ``//access``  ``　``BOOL` `bInherithandle,  ``//如果允许子进程继承句柄，则设为TRUE``  ``　``PCTSTR` `pszName  ``//指定要打开的对象的名字``  ``);`</span><br></pre></td></tr></table></figure>

<p>代码示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`#include &quot;stdafx.h&quot;``#include&lt;windows.h&gt;``#include&lt;iostream&gt;``using` `namespace` `std;` `int` `number = 1; ``//定义全局变量``HANDLE` `hSemaphore;  ``//定义信号量句柄` `unsigned ``long` `__stdcall ThreadProc1(``void``* lp)``&#123;``    ``long` `count;``    ``while` `(number &lt; 100)``    ``&#123;``        ``WaitForSingleObject(hSemaphore, INFINITE);  ``//等待信号量为有信号状态``        ``cout &lt;&lt; ``&quot;thread 1 :&quot;``&lt;&lt;number &lt;&lt; endl;``        ``++number;``        ``_sleep(100);``        ``ReleaseSemaphore(hSemaphore, 1, &amp;count);``    ``&#125;` `    ``return` `0;``&#125;` `unsigned ``long` `__stdcall ThreadProc2(``void``* lp)``&#123;``    ``long` `count;``    ``while` `(number &lt; 100)``    ``&#123;``        ``WaitForSingleObject(hSemaphore, INFINITE);  ``//等待信号量为有信号状态``        ``cout &lt;&lt; ``&quot;thread 2 :&quot;``&lt;&lt;number &lt;&lt; endl;``        ``++number;``        ``_sleep(100);``        ``ReleaseSemaphore(hSemaphore, 1, &amp;count);``    ``&#125;` `    ``return` `0;``&#125;` `int` `main()``&#123;``    ``hSemaphore = CreateSemaphore(NULL, 1, 100, ``&quot;sema&quot;``);` `    ``CreateThread(NULL, 0, ThreadProc1, NULL, 0, NULL);``    ``CreateThread(NULL, 0, ThreadProc2, NULL, 0, NULL);` `    ``Sleep(10*1000);` `    ``system``(``&quot;pause&quot;``);``    ``return` `0;``&#125;`</span><br></pre></td></tr></table></figure>

<p>　　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="https://img-blog.csdn.net/20170705230611602?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc19saXNoZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>可以看到，实现了有序输出，实现了线程间同步。</p>
<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>采用互斥对象机制。 只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享。</p>
<p>代码示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`#include &quot;stdafx.h&quot;``#include&lt;windows.h&gt;``#include&lt;iostream&gt;``using` `namespace` `std;` `int` `number = 1; ``//定义全局变量``HANDLE` `hMutex;  ``//定义互斥对象句柄` `unsigned ``long` `__stdcall ThreadProc1(``void``* lp)``&#123;``    ``while` `(number &lt; 100)``    ``&#123;``        ``WaitForSingleObject(hMutex, INFINITE);``        ``cout &lt;&lt; ``&quot;thread 1 :&quot;``&lt;&lt;number &lt;&lt; endl;``        ``++number;``        ``_sleep(100);``        ``ReleaseMutex(hMutex);``    ``&#125;` `    ``return` `0;``&#125;` `unsigned ``long` `__stdcall ThreadProc2(``void``* lp)``&#123;``    ``while` `(number &lt; 100)``    ``&#123;``        ``WaitForSingleObject(hMutex, INFINITE);``        ``cout &lt;&lt; ``&quot;thread 2 :&quot;``&lt;&lt;number &lt;&lt; endl;``        ``++number;``        ``_sleep(100);``        ``ReleaseMutex(hMutex);``    ``&#125;` `    ``return` `0;``&#125;` `int` `main()``&#123;``    ``hMutex = CreateMutex(NULL, ``false``, ``&quot;mutex&quot;``);     ``//创建互斥对象` `    ``CreateThread(NULL, 0, ThreadProc1, NULL, 0, NULL);``    ``CreateThread(NULL, 0, ThreadProc2, NULL, 0, NULL);` `    ``Sleep(10*1000);` `    ``system``(``&quot;pause&quot;``);``    ``return` `0;``&#125;`</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="https://img-blog.csdn.net/20170705225654422?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc19saXNoZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>可以看到，实现了有序输出，实现了线程同步。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/26/八大排序算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/26/八大排序算法/" itemprop="url">八大排序算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-26T12:07:39+08:00">
                2019-09-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>八大排序：冒泡排序，选择排序法，直接插入法，shell 排序法，快速排序，堆<br>排，归并排序，基数排序<br>冒泡排序<br>每次比较相邻的两个数，如果第一个比第二个大，就交换，一直比较到最后完<br>成一趟冒泡，每次冒泡最后的数变的有序，如果无序会进行 n-1 次的排序，直<br>到所有数都变得有序</p>
<p>时间复杂度：O（n*2） 优化后 O（n） 空间复杂度：O(1) 稳定性：稳定<br>void bublesort(int *arr, int len)<br>{<br>int tmp = 0;<br>for(int i=0;i&lt;len-1;i++)<br>{<br>bool swap =false;<br>for (int j = 0; j &lt; len- 1-i; j++)<br>{<br>if (arr[j] &gt; arr[j+1])<br>{<br>tmp = arr[j];<br>arr[j] = arr[j + 1];<br>arr[j + 1] = tmp;<br>swap = true;<br>}<br>}<br>if (!swap)<br>{<br>return;<br>}<br>}<br>}<br>选择排序法<br>选择法排序指每次选择所要排序的数组中的最大值（由小到大排序则选择最小值）<br>的数组元素，将这个数组元素的值与最前面没有进行排序的数组元素的值互换</p>
<p>时间复杂度：O(N*2) 空间复杂度：O(1) 稳定性：不稳定<br>void selectsort(int *arr,int len)<br>{<br>int tmp;<br>int i ;<br>int j ;<br>int min=0;<br>for ( i = 0; i &lt; len - 1; i++)<br>{<br>min = i;<br>for ( j = i+ 1; j &lt; len; j++)<br>{<br>if (arr[j] &lt; arr[min])<br>{<br>tmp = arr[j];<br>arr[j] = arr[min];<br>arr[min] = tmp;<br>}<br>}<br>}<br>}<br>直接插入法<br>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。比较是从有<br>序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果<br>比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰<br>见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。<br>所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的<br>顺序，所以插入排序是稳定的。</p>
<p>时间复杂度：O(n^2) 好的情况下 O(1) 空间复杂度：O（1） 稳定性：稳定<br>void insertsort(int *arr,int len)<br>{<br>int i,j,tmp;<br>for ( i = 1; i &lt; len; i++)<br>{<br>tmp = arr[i];<br>for (j = i - 1; i &gt;= 0;j–)<br>{<br>if (tmp &lt; arr[j])<br>{<br>arr[j + 1] = arr[j];<br>}<br>else<br>break;<br>}<br>arr[j + 1] = tmp;<br>}<br>}<br>shell  排序<br>Shell排序是直接插入排序的一种优化采用分组的思想，将一组数分成 n 各小组，<br>对每个小组进行插入排序，然后减小 n 值，重新分组，直到 n=1，最后 n 必须等<br>于1进行插入排序完成最终排序</p>
<p>时间复杂度：O（n^1.3~~n^1.5） 空间复杂度 O(1) 稳定性：不稳定<br>void Shell(int *arr, int len, int gap)<br>{<br>int tmp = 0;<br>int i, j;<br>for (i = gap; i &lt; len; i++)<br>{<br>tmp = arr[i];<br>for (j = i - gap; j &gt;= 0; j-=gap)<br>{<br>if (arr[j] &gt; tmp)<br>{<br>arr[j + gap] = arr[j];<br>}<br>else<br>break;<br>}<br>arr[j + gap] = tmp;<br>}<br>}<br>void shellsort(int *arr,int len)<br>{<br>int drr[] ={ 5,3,1 };<br>int lend = sizeof(drr) / sizeof(drr[0]);<br>for (int i = 0; i &lt; lend; i++)<br>{<br>Shell(arr, len, drr[i]);<br>}<br>}<br>快速排序<br>时间复杂度：好的情况O（nlog2n）坏的情况(有序)O(n^2)<br>空间复杂度：O(logn) 稳定性：不稳定<br>1、先从数列中取出一个数作为基准数<br>2、分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它<br>的左边<br>3、再对左右区间重复第二步，直到各区间只有一个数<br>以第一个数为基准将其放进 TMP 中从 high 开始比较如果 high&lt;tmp 则把 high 放<br>入 low，然后 low++，若 arr[low]&gt;tmp,则把 low 放入high，然后 high–,若<br>high&lt;tmp,则把high给low,然后Low++，进行循环</p>
<p>int Partation(int<em>arr,int low, int hign)<br>{<br>int tmp;<br>tmp = arr[low];<br>while (low &lt; hign)<br>{<br>while ((low&lt; hign) &amp;&amp; arr[hign] &gt;=tmp)<br>{<br>hign–;<br>}<br>if (low &gt;= hign)<br>{<br>break;<br>}<br>else<br>{<br>arr[low] = arr[hign];<br>}<br>while ((low&lt; hign) &amp;&amp; arr[low] &lt;= tmp)<br>{<br>low++;<br>}<br>if (low &gt;= hign)<br>{<br>break;<br>}<br>else<br>{<br>arr[hign] =arr[low];<br>}<br>}<br>arr[low] = tmp;<br>return low;<br>//查找 par 的位置，找到后刚好完成第一次快排<br>}<br>一，//递归<br>void quick(int <em>arr, int low, int hign)<br>{<br>int par = Partation(arr, low, hign);<br>if(par&gt;low+1)<br>{<br>quick(arr, low, par - 1);<br>}<br>//从第一次快速排列后的左边开始重新定义新的hign为par-1,并对左边进行快速排列，查找新的par<br>值<br>if (par &lt; hign - 1)<br>{<br>quick(arr, par + 1, hign);<br>}<br>//从第一次快速排列后的右边开始重新查找新的 low 为 0,并对右边进行快速排列，查找新的 par<br>}<br>void quicksort(int *arr,int len)<br>{<br>quick(arr, 0, len - 1);<br>//整个数列从头到尾查找 par 进行第一次快速排列<br>}<br>二//非递归 进行入栈操作进行排列<br>#include&lt;math.h&gt;<br>void quicksort1(int</em>arr, int len)<br>{<br>int tmpsize= (int)ceil(log((double)len));<br>int *stack = (int</em>)malloc(sizeof(int)<em>tmpsize</em>2);<br>//开辟栈的内存大小( O（nlog2n） )<br>assert(stack != NULL);<br>int low = 0;<br>int hign = len - 1;<br>int par = Partation(arr, 0, len - 1);<br>//第一次排序后为 9,5,13,2,6,20,32,25,76，查找第一个 par</p>
<p>int top = 0;<br>if (par &gt; low + 1)<br>{<br>stack[top++] = low;<br>stack[top++] = par - 1;<br>}<br>//对 par 的左边进行入栈操作，入栈 0,4<br>if (par &lt; hign-1)<br>{<br>stack[top++] = par + 1;<br>stack[top++] = hign;<br>}</p>
<p>//对 par 的右边进行入栈操作，入栈 6,8<br>while (top &gt; 0)<br>{<br>hign = stack[–top];<br>low = stack[–top];<br>par = Partation(arr, low, hign);<br>//（1.a）赋予 hign,low,par 新的位置，hign 位置为 8，low 位置为 6，par 位置为 7，先进行右侧<br>的排序</p>
<p>if (par &gt; low + 1)<br>{<br>stack[top++] = low;<br>stack[top++] = par - 1;<br>}<br>//（2），执行完（1）操作后，栈内所含数据为 0,4 对初始 par 的左边操作赋予 hign，low，par 新的<br>位置，此时 hign 位置为 4，low 位置为 0，par 位置为 3</p>
<p>//此时 par 的右侧有序不需执行下面的的操作，接下来再次执行 par 左侧的入栈操作，新栈<br>进栈数据 0,2</p>
<p>//再次重新 赋予 hign,low,par 新的位置，hign 位置为 2，low 位置为 0，par 位置为 1，此时数据排<br>序完成</p>
<p>if (par &lt; hign - 1)<br>{<br>stack[top++] = par + 1;<br>stack[top++] = hign;<br>}<br>//（1.b）对新 par 的右边进行入栈操作，此时（1.a）操作后右侧数据有序<br>}<br>}<br>快速排序的三种方法：<br>（1 ） 随机选取基准法<br>思想：取待排序列中任意一个元素作为基准<br>void Swap(int *arr, intlow, int hign)<br>{<br>int tmp = arr[low];<br>arr[low] = arr[hign];<br>arr[hign] =tmp;<br>}<br>//交换 low，hign 所在位置的值<br>void quick2(int *arr, int low, int hign)<br>{<br>Swap(arr, low, rand() %(hign - low) + low);<br>int par = Partation(arr, low, hign);<br>//交换 low 与随机产生 hign 的值,确定新的 hign，low，par 位置<br>if (par&gt;low+ 1)<br>{<br>quick2(arr,low, par - 1);<br>}<br>//对 par 左边进行排序<br>if (par &lt; hign - 1)<br>{<br>quick2(arr,par + 1, hign);<br>}<br>//对 par 右边进行排序<br>}<br>void quicksort2(int *arr, int len)<br>{<br>quick(arr, 0, len - 1);<br>}<br>（2 ） 三数取中法<br>void Median_of_three(int *arr, int low, int mid, int hign)<br>{<br>//取三个数的中间值 arr[mid]&lt;=arr[low]&lt;=arr[hign]<br>if (arr[mid] &gt; arr[low])<br>{<br>Swap(arr, mid,low);<br>}<br>if (arr[mid] &gt; arr[hign])<br>{<br>Swap(arr, mid, hign);<br>}<br>if (arr[low] &gt; arr[hign])<br>{<br>Swap(arr, low, hign);<br>}<br>void quick3(int *arr, int low, int hign)<br>{<br>Median_of_three(arr, low, (hign - low) / 2, hign);<br>//取待排列的序列中的 low，mid，hign 值，选取中间值为驱轴</p>
<p>int par = Partation(arr, low, hign);<br>if (par &lt; hign - 1)<br>{<br>quick3(arr,par + 1, hign);<br>}</p>
<p>if (par&gt;low+ 1)<br>{<br>quick3(arr,low, par - 1);<br>}</p>
<p>}<br>void quicksort3(int <em>arr, int len)<br>{<br>quick3(arr,0, len - 1);<br>}<br>（3 ） 基准聚拢法<br>待排序序列1467667686三数取中选取枢轴：下标为4的数6<br>转换后，待分割序列：6 467167686<br>枢轴key：6<br>第一步，在划分过程中，把与key相等元素放入数组的两端<br>结果为：6416(枢轴)787666<br>此时，与6相等的元素全放入在两端了<br>第二步，划分结束后，把与key相等的元素移到枢轴周围<br>结果为：1466(枢轴) 666787<br>此时，与6相等的元素全移到枢轴周围了<br>之后，在14和 787两个子序列进行快排<br>void Focus_Num(int *arr, int low, int par,int hign,int</em>left,int*right)<br>{<br>int i;<br>int Pleft =par - 1;<br>//聚拢左边相同数<br>for (i = par - 1; i &gt;= low; i–)<br>{<br>if (arr[i] == arr[par])<br>{<br>if (i == Pleft)<br>{<br>Pleft–;<br>}<br>//在 arr[i]==arr[par]的前提下，如果 i=Pleft,Pleft 向左移动，再次查找与 par 代表值相同的数<br>if (i != Pleft)<br>{<br>Swap(arr, i, Pleft);<br>Pleft–;<br>}<br>//在 arr[i]==arr[par]的前提下，如果 i！=Pleft,先交换 i 与 Pleft 所代表的值，再使 Pleft 向左<br>移动，再次查找与 par 代表值相同的数<br>}<br>}<br>int Pright = par + 1;<br>//聚拢右边相同数<br>for (i = par + 1; i &lt;= hign; i++)<br>{<br>if (arr[i] == arr[par])<br>{<br>if (i == Pright)<br>{<br>Pright++;<br>}<br>//在 arr[i]==arr[par]的前提下，如果 i=Pright,Pright 向右移动，再次查找与 par 代表值相同的<br>数<br>if (i != Pright)<br>{<br>Swap(arr, i, Pright);<br>Pright++;<br>}<br>//在 arr[i]==arr[par]的前提下，如果 i！=Pright,先交换 i 与 Pright 所代表的值，再使 Pright 向<br>右移动，再次查找与 par 代表值相同的数<br>}<br>}<br>*left = Pleft;<br>*right = Pright;<br>}<br>void quick4(int *arr, int low, int hign)<br>{<br>int par = Partation(arr, low, hign);<br>int left=par-1;<br>int right=par+1;<br>Focus_Num(arr, low, par, hign,&amp;left,&amp;right);<br>if (par&gt;low+ 1)<br>{<br>quick4(arr,low,left);<br>}<br>if (par &lt; hign - 1)<br>{<br>quick4(arr,right, hign);<br>}<br>}<br>void quicksort4(int *arr, int len)<br>{<br>quick4(arr,0, len - 1);<br>}<br>堆排<br>时间复杂度：O（nlog2n）最好最坏情况<br>空间复杂度:O（1) 稳定性：不稳定<br>堆排序是一种树形选择排序，在排序过程中可以把元素看成是一颗完全二叉树，<br>每个节点都大（小）于它的两个子节点，当每个节点都大于等于它的两个子节点<br>时，就称为大顶堆，也叫堆有序； 当每个节点都小于等于它的两个子节点时，<br>就称为小根堆。<br>思路（大根堆）：<br>（1）将长度为n的待排序的数组进行堆有序化构成一个大顶堆；<br>（2）将根节点与尾节点交换并输出此时的尾节点；<br>（3）将剩余的n-1个节点重新进行堆有序化；<br>（4）重复进行（2）（3）步骤直至构成一个有序序列</p>
<p>void adjust(int<em>arr, int start, intend)<br>{<br>//将原数列调整为大根堆<br>int tmp;<br>tmp = arr[start];<br>//由子代（n）推出父代 ——————&gt; （n-1）/2<br>//由父代（n）推出子代 ——————&gt; 左子叶（2n+2）右子叶(2n+2)<br>for (int i = 2 * start + 1; i &lt;= end; i = 2 * i+ 1)<br>{<br>//i 为最后一个子叶的父代所在的位置<br>if (i &lt; end&amp;&amp; arr[i] &lt;arr[i + 1])<br>{<br>i++;//i 当前的下标肯定是左右孩子里最大的值<br>}<br>if (arr[i] &gt; tmp)<br>{<br>arr[start] = arr[i];<br>start = i;<br>}<br>else<br>{<br>break;<br>}<br>}<br>arr[start] = tmp;<br>//将 start 所代表的值赋值给 tmp,并将其与子代值进行比较，值小的置于 start 值所在的位置，再<br>进行下一个 start 操作，逐步将较大的值置于底部<br>}<br>void heapsort(int</em>arr, int len)<br>{<br>for (int i = (len - 1 -1) / 2; i &gt;= 0; i–)<br>{<br>adjust(arr,i, len - 1);<br>}<br>//第一次构造成大根堆</p>
<p>int tmp = 0;<br>for (int i = 0; i &lt; len- 1; i++)<br>{<br>tmp = arr[0];<br>arr[0] = arr[len - 1 - i];<br>arr[len - 1- i] = tmp;<br>//根与最后的子叶交换，此时最大值位置确定<br>adjust(arr,0, len-1-i-1);<br>//再次将剩余数据构造大顶推树并进行根与最后子叶的交换，每交换一次确定出剩余数据最大值的位<br>置<br>}<br>}</p>
<p>归并排序<br>时间复杂度：O(nlog2n) 空间复杂度：O(n) 稳定性：稳定<br>即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序<br>表，称为二路归并。<br>对以下数据5 10 8 14 19 1 35 25，单个数据有序，再进行排序使两个<br>两个数据有序，如下图示：</p>
<p>void Merge(int<em>arr, intlen, int gap)<br>{<br>//申请一个数组<br>int *brr = (int</em>)malloc(sizeof(int)*len);<br>assert(brr != NULL);<br>//判断 start1，end1，start2，end2 的位置<br>int i = 0;<br>int s1 = 0;<br>int e1 = s1+gap - 1;;<br>int s2 = e1+ 1;<br>int e2 = s2+gap-1&lt;len-1?s2+gap-1:len-1;<br>//当有两个归并段时<br>while (s2 &lt;len)<br>{<br>//两个归并段都有数据<br>while ((s1 &lt;= e1) &amp;&amp; (s2 &lt;= e2))<br>{<br>if (arr[s1]&lt;= arr[s2])<br>{<br>brr[i++] = arr[s1++];<br>}<br>else<br>{<br>brr[i++] = arr[s2++];<br>}<br>}</p>
<p>//退出循环的两种方式<br>while (s1 &lt;= e1)<br>{<br>brr[i++]=arr[s1++];<br>}<br>while (s2 &lt;= e2)<br>{<br>brr[i++] = arr[s2++];<br>}<br>s1 = e2 + 1;<br>e1 = s1 + gap - 1;;<br>s2 = e1 + 1;<br>e2 = s2 + gap - 1&lt;len - 1 ? s2 + gap - 1 : len- 1;<br>}<br>//只有一个归并段时<br>while (s1 &lt;len)<br>{<br>brr[i++] = arr[s1++];<br>}<br>for (int i = 0; i &lt; len; i++)<br>{<br>arr[i]=brr[i];<br>}<br>free(brr);<br>brr = NULL;<br>}<br>void Mergesort(int <em>arr, int len)<br>{<br>for (int i = 1; i &lt; len; i</em>=2)<br>{<br>Merge(arr, len, i);<br>}<br>}<br>基数排序<br>又称桶子法，根据当前待排序的每一位上的数字进行入桶排序，桶的数量跟当前<br>单个数字的取值范围有关等到最低位排完得到一个子序列，再将这个序列按照次<br>低位的大小进入相应的桶中，一直排到最高位为止，数组排序完成。</p>
<p>//每个桶内存储数据时相当于进行单链表的操作，创建单链表<br>typedef struct Node<br>{<br>int data;<br>struct Node<em>next;<br>}Node, *List;<br>//单链表的初始化<br>void InitList(List plist)<br>{<br>assert(plist != NULL);<br>plist-&gt;next= NULL;<br>}<br>//新建一个节点<br>static Node</em>GetNode(int val)<br>{<br>Node *pGet = (Node *)malloc(sizeof(Node));<br>assert(pGet!= NULL);<br>pGet-&gt;data = val;<br>pGet-&gt;next = NULL;<br>return pGet;<br>}<br>//单链表的插入操作，尾插。入桶<br>bool Insert(List plist,int val)<br>{<br>Node *p = plist;<br>while (p-&gt;next != NULL)<br>{<br>p = p-&gt;next;<br>}<br>Node *pGet = GetNode(val);<br>p-&gt;next = pGet;<br>return true;<br>}<br>//删除并保存值，出桶操作<br>bool DelFirst(List plist, int *rtv)<br>{<br>Node *p = plist-&gt;next;<br>if (p == NULL)<br>{<br>return false;<br>}<br>*rtv = p-&gt;data;<br>plist-&gt;next= p-&gt;next;<br>free(p);<br>p = NULL;<br>return true;<br>}<br>//找出最大数并确定最大数的位数<br>int GetBitMax(int *arr,int len)<br>{<br>int max = arr[0];<br>int count =0;<br>for (int i = 1; i &lt; len;i++)<br>{<br>if (arr[i] &gt; max)<br>{<br>max = arr[i];<br>}<br>}<br>while (max != 0)<br>{<br>count++;<br>max /= 10;<br>}<br>return count;<br>}<br>//得到 figure 位上的数值<br>int Getnum(int num, intfigure)<br>{<br>for (int j = 0; j &lt; figure; j++)<br>{<br>num = num /10;<br>}<br>return num % 10;<br>}<br>void Base(int *arr, intlen, int figure)<br>{<br>assert(arr != NULL);<br>//创建桶<br>Node head[10];<br>for (int j = 0; j &lt; 10;j++)<br>{<br>InitList(&amp;head[j]);//初始化<br>}<br>int tmp;<br>for (int j = 0; j &lt; len; j++)<br>{<br>tmp = Getnum(arr[j], figure);//得到 j 号下表 figure 位的数值<br>Insert(&amp;head[tmp], arr[j]);<br>//入桶，遍历数组 figure 位相应的数据进入相应的桶里<br>}<br>int n = 0;<br>for (int j = 0; j &lt; 10;)<br>{<br>if (DelFirst(&amp;head[j], &amp;arr[n]))<br>{</p>
<p>n++;//j 号桶不一定只有一个数据，遍历整个数组用 n 代表一个桶里存放数据的下表，<br>避免出现多个数据使数据存放出现问题，覆盖掉原先值或赋值后不改变<br>}<br>else<br>{<br>j++;//下一个桶<br>}<br>}<br>}<br>void Basesort(int *arr,int len)<br>{<br>int count =GetBitMax(arr, len);<br>for (int i = 0; i &lt; count; i++)<br>{<br>Base(arr, len, i);//i 表示当前数字从右往左数的位数<br>}<br>}<br>————————————————<br>版权声明：本文为CSDN博主「一步两步先生」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_42323413/article/details/83001018" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42323413/article/details/83001018</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/26/C-面试题基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/26/C-面试题基础/" itemprop="url">C++面试题基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-26T11:50:49+08:00">
                2019-09-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="C语言编译过程为：预处理–-gt-编译–-gt-汇编–-gt-链接"><a href="#C语言编译过程为：预处理–-gt-编译–-gt-汇编–-gt-链接" class="headerlink" title="C语言编译过程为：预处理–&gt;编译–&gt;汇编–&gt;链接"></a>C语言编译过程为：预处理–&gt;编译–&gt;汇编–&gt;链接</h3><p>1、预处理（Pre-processing）</p>
<pre><code>对源程序中的伪指令（以#开头的指令）和特殊符号进行处理。伪指令包括：宏定义指令、条件编译指令、头文件包含指令。</code></pre><p>2、编译（Compiling）</p>
<pre><code>将源程序转换为计算机可以执行的二进制代码。

说明：在linux下，目录文件的缺省后缀为 .o

 编译程序将通过词法分析和语法分析，将其翻译为等价的汇编代码。在使用gcc编译时，缺省情况下不输出此汇编代码文件，       如果需要可在编译时指定 -s 选项，这样就会输出同名的汇编文件。</code></pre><p>3、汇编（Assembling）</p>
<pre><code>将汇编语言代码翻译为机器语言的过程，产生一个名为 .o 的目标文件。</code></pre><p>4、链接（Linking）</p>
<pre><code>目标代码不能直接执行，要将目标代码变为可执行程序，还需要进行链接操作，这样才会生产真正可执行的程序。

链接操作最重要的步骤就是将函数库中的相应代码组合到目标文件中。</code></pre><p>原文链接：<a href="https://blog.csdn.net/M_joy666/article/details/79776856" target="_blank" rel="noopener">https://blog.csdn.net/M_joy666/article/details/79776856</a></p>
<h2 id="经典C语言面试题1：malloc-和-new的区别？"><a href="#经典C语言面试题1：malloc-和-new的区别？" class="headerlink" title="经典C语言面试题1：malloc 和 new的区别？"></a>经典C语言面试题1：malloc 和 new的区别？</h2><p>①、malloc/ free是 C++/C语言的标准库函数，而new/ delete是C++的运算符。</p>
<p>②、malloc内存分配成功返回的类型为void<em>，需要通过强制类型转换将void</em>转换为我们需要的类型。</p>
<p>③、new内存分配失败时会抛出bac_alloc异常，不会返回NULL；而malloc分配失败时则返回NULL。</p>
<p>④、使用new操作符申请内存分配是无需指定内存块的大小，而malloc则需要显式地指出所需的内存大小。<br>原文链接：<a href="https://blog.csdn.net/M_joy666/article/details/79777012" target="_blank" rel="noopener">https://blog.csdn.net/M_joy666/article/details/79777012</a></p>
<h2 id="经典C语言面试题2：static关键字的用法"><a href="#经典C语言面试题2：static关键字的用法" class="headerlink" title="经典C语言面试题2：static关键字的用法"></a>经典C语言面试题2：static关键字的用法</h2><p>C语言中static关键字的用法主要有以下三种：</p>
<p>1、在函数体内，static变量的作用范围为该函数体，该变量的内存只能被分配一次，下次调用时维持上次的值（即具有记忆功能）。</p>
<p>2、在模块内的static全局变量可以被模块内的所有函数访问，但是不能被模块外的函数访问（注：即使在模块外的函数中加extern也不行）。</p>
<p>3、在模块内的static函数只可以被模块内其他函数调用，此函数的作用域被限制在声明它的模块之中。</p>
<p>综上：在全局变量前加上static则限制了其作用域（存储区均在全局区）；在局部变量前加static改变了其存储区（由栈上变为全局区）。<br>原文链接：<a href="https://blog.csdn.net/M_joy666/article/details/79779205" target="_blank" rel="noopener">https://blog.csdn.net/M_joy666/article/details/79779205</a></p>
<h2 id="经典C语言面试题3：位域"><a href="#经典C语言面试题3：位域" class="headerlink" title="经典C语言面试题3：位域"></a>经典C语言面试题3：位域</h2><p>1、为什么要用位域？</p>
<pre><code> 在计算机中，有些信息存储时并不需要占用一个完整的字节，而只需占用一个或几个二进制位。比如在存放一个只有0和1两种状态的开关量时，用一位二进制位即可表示。因此，为了节省存储空间，C语言提供了一种称为“位域”的数据结构来充分利用存储空间。

位域的主要实现方式：把一个字节中的二进制位划分为几个不同的区域，并说明每个区域的位数，每个域有一个域名，允许在程序中按域名进行操作，这样就可以将几个不同的对象用一个字节的二进制位域表示。</code></pre><p>  2、 如何定义</p>
<pre><code>位域的定义与结构体定义相似，形式如下：</code></pre><p>struct 位域结构名<br>{<br>  类型说明符 位域名: 位域长度;<br>};<br> 例如：</p>
<p>struct time<br>{<br>   int a:8;<br>   int b:2;<br>   int c:6;<br>}data;//data为time变量，共占用2个字节<br> 注：位域变量的说明与结构体变量的说明方式相同。可以先定义后说明、同时定义说明以及直接说明三种方式。</p>
<p> 使用注意事项：</p>
<p>①、一个位域必须存储在同一个字节中，不能跨两个字节，如果一个字节所剩空间不够存放下一位域时，应该从下一个单元开      始，当然也可以有意调整使其从下一个单元开始；</p>
<p>struct data<br>{<br>   unsigned a: 4;<br>   unsigned :0;//空域,用0填充4位<br>   unsigned b:4;<br>   unsigned c:4;<br>};</p>
<p>②、位域长度不能大于一个字节的长度，即不能超过8位；</p>
<p>③、可以定义无名位域用来做填充或调整位置。</p>
<p>struct num<br>{<br>   int a:1;<br>   int :2;//无名位域，用来填充<br>   int b:3;<br>   int c:2:<br>};<br>3、如何调用</p>
<pre><code>位域的调用方式和结构成员调用方式相同，形式为：

位域变量名 . 位域名</code></pre><p>   一个完整的例子如下：</p>
<p>#include&lt;stdio.h&gt;</p>
<p>int  main()<br>{</p>
<p>struct test<br>{<br>   unsigned a:1;<br>   unsigned b:3;<br>   unsigned c:4;<br>}tst,*ptst;<br>tst.a = 6;<br>tst.b = 6;<br>tst.c = 6;<br>printf(“a:%d,b:%d,c:%d\n”,tst.a,tst.b,tst.c);<br>ptst = &tst;<br>ptst-&gt;a = 8;<br>ptst-&gt;b = 8;<br>ptst-&gt;c = 8;<br>printf(“a:%d,b:%d,c:%d\n”,ptst-&gt;a,ptst-&gt;b,ptst-&gt;c);<br>return 0;<br>}</p>
<p>综上：从本质上说，位域是一种结构类型，只不过其成员是按照二进制位来分配的。<br>————————————————<br>版权声明：本文为CSDN博主「喝橙汁的嗷大喵」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/M_joy666/article/details/79779340" target="_blank" rel="noopener">https://blog.csdn.net/M_joy666/article/details/79779340</a></p>
<h2 id="经典C语言面试题4：字节对齐的作用"><a href="#经典C语言面试题4：字节对齐的作用" class="headerlink" title="经典C语言面试题4：字节对齐的作用"></a>经典C语言面试题4：字节对齐的作用</h2><p>   一、什么是字节对齐？ </p>
<pre><code>在现代计算机中，内存空间都是按照字节(byte)划分的。从理论上讲对任何类型的变量的访问可以从任何地址开始，但实际情况是，访问特定类型的变量的时候经常在特定的内存地址访问，这就需要各种类型的数据按照一定规则在空间上排列，而不是顺序地一个接一个地排放，这种所谓的规则就是字节对齐。这么长一段话的意思是说：字节对齐可以提升存取效率，也就是用空间换时间。</code></pre><p>例如：</p>
<p>struct A<br>{<br>   char a;<br>   char reserved[3];//使用空间换时间<br>   int b;<br>};</p>
<p><img src="https://img-blog.csdn.net/20180421171101857?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01fam95NjY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>注：其中的reserved成员对于程序并没有意义，只是起到了填补空间达到字节对齐的目的。当然，即使不加这个成员，编译器也会自动为我们补齐，加上它只是起到显式提醒。</p>
<p>二、为什么需要字节对齐？</p>
<pre><code>因为各个硬件平台对存储空间的处理上有很大的不同，一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问一个没有进行对齐的变量的时候会发生错误,那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。</code></pre><p>三、几个基本概念</p>
<p>1、基本数据类型的自身对齐值</p>
<pre><code>例如，char型数据的自身对齐值为1字节，short类型自身对齐值为2字节，int、float、long类型自身对齐值均为4字节，double类型自身对齐值均为8字节。（32位系统）</code></pre><p>2、结构体或类的自身对齐值</p>
<pre><code>其成员中自身对齐值最大的那个值。</code></pre><p>3、指定对齐值</p>
<pre><code>通过预编译指令 #pragma pack (value) 来指定的对齐值value。（注：取消自定义对齐值得指令为 #pragma pack ( )）</code></pre><p>4、数据成员、结构体和类的有效对齐值</p>
<pre><code>其自身对齐值和指定对齐值中较小的那个值。</code></pre><p>四、字节对齐的几个例子浅析</p>
<p>例1：设有如下两个结构体</p>
<p>struct A<br>{<br>  char a;<br>  short b;<br>  int c;<br>};<br>struct B<br>{<br>  short b;<br>  int c;<br>  char a;<br>};<br>那么上面两个结构体的大小是多少呢？</p>
<p>对于结构体A：a是char型数据，占用1字节内存；short型数据，占用2字节内存；int型数据，占用4字节内存。因此，结构体A的自身对齐值为4，sizeof(struct A) =8字节。由于结构体类型数据是按顺序存储结构一个接一个向后排列的，于是其存储方式为：</p>
<p>为了更加明显地表示“对齐”，我们可以将以上结构想象为以下的行排列：</p>
<p>对于结构体B：同理也是4字节对齐，但是sizeof(struct B) =12字节。</p>
<p>想象为以下的行排列：</p>
<p>例2：为结构体指定对齐值</p>
<p>pragma pack(2) //指定2字节对齐</p>
<p>struct C<br>{<br>  char a;<br>  int b;<br>  short c;<br>};</p>
<p>pragma pack() //取消指定对齐，恢复缺省对齐</p>
<p>对于结构体C：由于其自身对齐值为4字节（int b），而指定对齐值为2字节，因此该结构体的有效对齐值为较小的2字节，那么sizeof(struct C) = 8 字节。</p>
<p>pragma pack(1) //指定1字节对齐</p>
<p>struct D<br>{<br>  char a;<br>  int b;<br>  short c;<br>};</p>
<p>pragma pack() //取消指定对齐，恢复缺省对齐</p>
<p>对于结构体D：同理可知，由于其自身对齐值为4字节（int b），而指定对齐值为1字节，因此该结构体的有效对齐值为较小的1字节，那么sizeof(struct D) = 7 字节。</p>
<p>​    </p>
<p>五、总结</p>
<p>由以上分析可知，字节对齐会造成空间上的浪费。 事实上，除了结构体之外，整个程序在给每个变量进行内存分配时都会遵循对齐机制，也都会产生内存空间的浪费。但我们要知道，这种浪费是值得的，因为它换来的是效率的提高。<br>————————————————<br>版权声明：本文为CSDN博主「喝橙汁的嗷大喵」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/M_joy666/article/details/80030024" target="_blank" rel="noopener">https://blog.csdn.net/M_joy666/article/details/80030024</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/26/C-面试题准备/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/26/C-面试题准备/" itemprop="url">C++面试题准备</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-26T11:15:06+08:00">
                2019-09-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="C-笔试题准备"><a href="#C-笔试题准备" class="headerlink" title="C++笔试题准备"></a>C++笔试题准备</h2><h4 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h4><p>1.指针是变量，这个变量存放的是所指内容的地址，引用是别名，与所引用的变量占用同一内存空间</p>
<p>2.指针可以为空，但引用值不能为空，在定义时必须初始化</p>
<p>3.指针的值可以改变，但是引用在初始化后不可改变</p>
<p>4.sizeof引用得到的是所指向的变量的的大小</p>
<p>sizeof指针得到的是指针本身的大小</p>
<p>5.都可以作为函数参数。引用的主要作用是传递函数的参数和返回值</p>
<h3 id="typedef和define的区别"><a href="#typedef和define的区别" class="headerlink" title="typedef和define的区别"></a>typedef和define的区别</h3><p>1.用法不同：typedf用来定义一种数据类型的别名，增强程序的可读性。define主要用来定义常量，以及书写复杂使用频繁的宏。(<a href="https://www.jianshu.com/p/cbb6b71d925d宏的使用" target="_blank" rel="noopener">https://www.jianshu.com/p/cbb6b71d925d宏的使用</a>)</p>
<p>2.执行时间不同：typedef是编译过程的一部分，有类型检查，define是宏定义，不检查类型</p>
<p>3.作用域不同：typedef有作用域限定，define不受作用域限定，只要是在define声明后的引用都是正确的</p>
<p>4.对指针的操作不同：typedef和define定义指针时候有很大区别</p>
<p>typedef定义是语句，后面句尾要加分号，define不是语句，后面不能加分号</p>
<h3 id="Static在c-c-中的区别和用法（https-blog-csdn-net-weixin-42323413-article-details-89146305）"><a href="#Static在c-c-中的区别和用法（https-blog-csdn-net-weixin-42323413-article-details-89146305）" class="headerlink" title="Static在c/c++中的区别和用法（https://blog.csdn.net/weixin_42323413/article/details/89146305）"></a>Static在c/c++中的区别和用法（<a href="https://blog.csdn.net/weixin_42323413/article/details/89146305）" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42323413/article/details/89146305）</a></h3><p>1.局部静态变量</p>
<p>2.外部静态变量/函数</p>
<p>3.静态数据成员/成员函数</p>
<h3 id="简述指针常量和常量指针的区别？关键字const是什么？static有什么作用？extern有什么作用？"><a href="#简述指针常量和常量指针的区别？关键字const是什么？static有什么作用？extern有什么作用？" class="headerlink" title="简述指针常量和常量指针的区别？关键字const是什么？static有什么作用？extern有什么作用？"></a>简述指针常量和常量指针的区别？关键字const是什么？static有什么作用？extern有什么作用？</h3><p>指针常量是指定义了一个指针，这个指针的值只能在定义时初始化，其他地方不能改变。常量指针<br>是指定义了一个指针，这个指针指向一个只读的对象，不能通过常量指针来改变这个对象的值。<br>指针常量强调的是指针的不可改变性，而常量指针强调的是指针对其所指对象的不可改变性。</p>
<p>const 用来定义一个只读的变量或对象。主要优点：便于类型检查、同宏定义一样可以方便地进行<br>参数的修改和调整、节省空间，避免不必要的内存分配、可为函数重载提供参考。<br>const 修饰函数参数，是一种编程规范的要求，便于阅读，一看即知这个参数不能被改变，<br>实现时不易出错。</p>
<p>static 在 C 中主要用于定义全局静态变量、定义局部静态变量、定义静态函数。在 C++中新增了两<br>种作用：定义静态数据成员、静态函数成员。<br>因为 static 定义的变量分配在静态区，所以其定义的变量的默认值为 0，普通变量的默认值<br>为随机数，在定义指针变量时要特别注意。</p>
<p>extern 标识的变量或者函数声明其定义在别的文件中，提示编译器遇到此变量和函数时在其它模块<br>中寻找其定义。<br>原文链接：<a href="https://blog.csdn.net/weixin_42323413/article/details/84920086" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42323413/article/details/84920086</a></p>
<h3 id="C-函数重载重写与隐藏"><a href="#C-函数重载重写与隐藏" class="headerlink" title="C++函数重载重写与隐藏"></a>C++函数重载重写与隐藏</h3><p>1、几个概念与区别<br>（1）函数重写：也称作覆盖，是用于类的继承中，函数名、参数个数、类型都相同，仅函数体不同。<br>（2）函数重载：是指同一作用域的不同函数使用相同的函数名，但是参数个数或类型不同。<br>（3）函数隐藏：既不是重载也不是重写，例如：函数名及参数完全相同却又不是虚函数，却在子类中重新实现该函数，也就是所谓的隐藏。</p>
<p>2、重写/覆盖<br>（1）重写是指派生类函数覆盖基类函数。<br>（2）重写的特征：<br>①不同的作用域（分别位于派生类与基类）；<br>②函数名字相同；<br>③参数相同；<br>④基类函数必须是虚函数；<br>⑤重写函数必须和原函数具有相同的返回类型；<br>⑥const可能会使虚成员函数的重写失效。<br>原文链接：<a href="https://blog.csdn.net/buknow/article/details/80517594" target="_blank" rel="noopener">https://blog.csdn.net/buknow/article/details/80517594</a></p>
<h2 id="简述C，C-程序编译的内存分配情况"><a href="#简述C，C-程序编译的内存分配情况" class="headerlink" title="简述C，C++程序编译的内存分配情况"></a>简述C，C++程序编译的内存分配情况</h2><p>一个C，C++程序编译时内存分为5大存储区：堆区，栈区，全局区，文字常量区，程序代码区。</p>
<p>C，C++中内存分配方式可以分为三种：<br>（1）从静态存储区域分配：<br>内存在程序编译时就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量等。<br>（2）在栈上分配：<br>在执行函数时，函数内局部变量的存储单元都在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。<br>（3）从堆上分配：<br>即动态内存分配。程序在运行的时候用malloc或new申请任意大小的内存，程序员负责在何时用free或delete释放内存。动态内存的生存期由程序员决定，使用灵活。<br>当在堆上分配了空间，就有责任回收它，否则运行的程序会出现内存泄漏。其次频繁地分配和释放不同大小的对空间将会产生堆内碎块<br>————————————————<br>版权声明：本文为CSDN博主「一步两步先生」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_42323413/article/details/84886597" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42323413/article/details/84886597</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/26/python基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/26/python基础/" itemprop="url">python基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-26T01:11:30+08:00">
                2019-09-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#python基础知识</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>环境变量指的就是操作系统中的一些变量</p>
<p>可以通过修改环境变量来对计算机进行配置，主要是用来配置存储路径</p>
<p>一个环境变量可以是多个值，值与值之间用：隔开（mac上），用；隔开（windows）</p>
<h3 id="Mac-上配置环境变量"><a href="#Mac-上配置环境变量" class="headerlink" title="Mac 上配置环境变量"></a>Mac 上配置环境变量</h3><p>mac系统的环境变量，加载顺序为：</p>
<p>a./etc/profile</p>
<p>b.etc/paths</p>
<p>c.~/.bash_profile</p>
<p>d.~/bash_login</p>
<p>e~/.profile</p>
<p>f.~/.bashrc</p>
<p>其中a和b是系统级别的。系统启动就会加载，其余的是用户级别的。</p>
<p>c,d,e按照从前往后的顺序读取，如果c存在后续就忽略不读，依此类推。</p>
<p>～/.bashrc没有上述规则，他是bash shell 打开时就载入。</p>
<h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><p>十进制</p>
<p>十六进制   1 2 3 4 5 6 7 8 9 a b c d e f</p>
<h3 id="文本和字符集"><a href="#文本和字符集" class="headerlink" title="文本和字符集"></a>文本和字符集</h3><p>纯文本，富文本，纯文本只能保存单一的文本，不能保存除文字以外的内容，开发程序使用纯文本</p>
<p>将字符转换为二进制为编码。将二进制转换为字符，解码。</p>
<p>编码和解码常用的规则，称为字符集。</p>
<p>ASCII</p>
<p>-美国人编码，使用7位来对美国常见字符进行编码</p>
<p>-包含128个字符</p>
<p>ISO-8859-1</p>
<p>-欧洲的编码，使用8位</p>
<p>-包含256个字符</p>
<p>GB2312</p>
<p>GBK</p>
<p>-国标码，中国码</p>
<p>unicode</p>
<p>-万国码，包含世界上所有的语言和符号</p>
<p>编写程序时，一般使用unicode，有多种实现方法</p>
<p>UTF-8。 1-5个字节</p>
<p>UTF-16。2-4个字节</p>
<p>UTF-32。固定使用4个字节Byte</p>
<p>乱码</p>
<p>马上检查字符集是否正确</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/24/VGG-16模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/24/VGG-16模型/" itemprop="url">VGG-16模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-24T10:20:54+08:00">
                2019-09-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="卷积神经网络VGG16这么简单，为什么没人能说清？"><a href="#卷积神经网络VGG16这么简单，为什么没人能说清？" class="headerlink" title="卷积神经网络VGG16这么简单，为什么没人能说清？"></a>卷积神经网络VGG16这么简单，为什么没人能说清？</h1><p>2018-07-15 18:43</p>
<p>很多人想入门做深度学习，但往往翻遍网络看完一篇又一篇所谓的“入门教程”，paper，包括很多深度学习框架官方给出的案例，给人的感觉真的是从入门到放弃。写教程的作者有很多都是技术大神，但写出的东西真的是把原本简简单单的理论说得晦涩难懂，模凌两可。比如说VGG16，都是摆上从论文里截过来的下面这张图：</p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180715/840ebea73b1b4f1fa7f5ad496ec6ae6c.jpeg" alt="img"></p>
<p>或者给出像下面的架构图：</p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180715/e9fd04d524814a239891a8d786d0aa97.jpeg" alt="img"></p>
<p>对于数据从输入到输出，中间是如何变化的，神经元个数，参数个数又是怎么变化的，如何自己设计一个合理的CNN网络等等，没有教程能把这些说清楚，推荐看吴恩达老师的课程视频，对英文不好的童鞋其实是很吃力的。入门其实并不难，内容也不难理解，倒是被千篇一律的教程带进沟来。</p>
<p>VGG16本来就简单，但是越简单的东西”大牛”们往往不想去解释，说是“入门教程”，基础的不解释怎么教人入门。</p>
<p>现在详细介绍VGG16 , 需要补充一点神经网络的知识，9行Python代码搭建神经网络来掌握一些基本概念</p>
<p><strong>一张图片如何作为输入？</strong></p>
<p>如下图，彩色图像有RGB三个色值通道，分别表示红、绿、蓝，每个通道内的像素可以用一个像下图右边的二维数组表示，数值代表0-255之间的像素值。假设一张900<em>600的彩色的图片，计算机里面可以用 (900</em>600*3)的数组表示。</p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180715/7b0a8af806b940fd86c62e3884f770bb.jpeg" alt="img"></p>
<p><strong>什么是卷积</strong></p>
<p>卷积过程是基于一个小矩阵，也就是卷积核，在上面所说的每层像素矩阵上不断按步长扫过去的，扫到数与卷积核对应位置的数相乘，然后求总和，每扫一次，得到一个值，全部扫完则生成一个新的矩阵。如下图</p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180715/54ea427933f94b588a087bbd42e0c6b9.gif" alt="img"></p>
<p>卷积核如何设置可以参考卷积神经网络的卷积核大小、个数，卷积层数如何确定呢？一般取(3,3)的小矩阵，卷积核里面每个值就是我们需要寻找（训练）的神经元参数(权重)，开始会随机有个初始值，当训练网络时，网络会通过后向传播不断更新这些参数值，直到寻找到最佳的参数值。如何知道是“最佳”？是通过损失函数去评估。</p>
<p>卷积核的步长是指卷积核每次移动几个格子，有横行和纵向两个方向。</p>
<p>卷积操作相当于特征提取，卷积核相当于一个过滤器，提取我们需要的特征。</p>
<p>如下图，左边小红色框是卷积核，从左上角扫到右下角，最终得到右边的特征图谱。</p>
<p>卷积：如何成为一个很厉害的神经网络</p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180715/d4bb317688cf4f20b98ecef61a137b7b.jpeg" alt="img"></p>
<p><strong>什么是Padding</strong></p>
<p>卷积操作之后维度变少，得到的矩阵比原来矩阵小，这样不好计算，而我们只是希望作卷积，所以我们需要Padding，<strong>在每次卷积操作之前</strong>，在原矩阵外边补包一层0，可以只在横向补，或只在纵向补，或者四周都补0，从而使得卷积后输出的图像跟输入图像在尺寸上一致。</p>
<p>比如：我们需要做一个300<em>300的原始矩阵的卷积，用一个3</em>3卷积核来扫，扫出来结果的矩阵应该是：298*298的矩阵，变小了。</p>
<p>卷积前加 <strong>Padding</strong> 操作补一圈0，即300<em>300矩阵外面周围加一圈“0”，这样的300</em>300就变成了302<em>302的矩阵，再进行卷积出来就是300</em>300 ，尺寸和原图一样。</p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180715/0640c2c6b25847a99883432b8816a3c6.jpeg" alt="img"></p>
<p><strong>什么是池化(pooling)</strong></p>
<p>卷积操作后我们提取了很多特征信息，相邻区域有相似特征信息，可以相互替代的，如果全部保留这些特征信息就会有信息冗余，增加了计算难度，这时候池化就相当于降维操作。池化是在一个小矩阵区域内，取该区域的最大值或平均值来代替该区域，该小矩阵的大小可以在搭建网络的时候自己设置。小矩阵也是从左上角扫到右下角。如下图</p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180715/f70b4f66555c4ace8756c3eb59fc10f9.gif" alt="img"></p>
<p><strong>什么是Flatten</strong></p>
<p>Flatten 是指将多维的矩阵拉开，变成一维向量来表示。</p>
<p><strong>什么是全连接层</strong></p>
<p>对n-1层和n层而言，n-1层的任意一个节点，都和第n层所有节点有连接。即第n层的每个节点在进行计算的时候，激活函数的输入是n-1层所有节点的加权。像下面的<strong>中间层</strong>就是全连接方式。</p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180715/5cea91f9793a47da8928ae5a83037ddb.jpeg" alt="img"></p>
<p><strong>什么是Dropout</strong></p>
<p>dropout是指在网络的训练过程中，按照一定的概率将网络中的神经元丢弃，这样有效防止过拟合。</p>
<p>现在我们来看看VGG16的整天架构图：</p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180715/9bb7534dc4a44496a995dc5c30cac0cd.jpeg" alt="img"></p>
<p>从左至右，一张彩色图片输入到网络，白色框是卷积层，红色是池化，蓝色是全连接层，棕色框是预测层。预测层的作用是将全连接层输出的信息转化为相应的类别概率，而起到分类作用。</p>
<p>可以看到 VGG16 是13个卷积层+3个全连接层叠加而成。</p>
<p><strong>以下是一个基于kares 的VGG6 代码：</strong></p>
<p><strong>完整代码地址：</strong></p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180715/ca4c345db12d47b39292b72d26bde1d2.jpeg" alt="img"></p>
<p>详细解释一下代码</p>
<p>网络开始输入(3,224,224)的图像数据，即一张宽224，高244的彩色RGB图片，同时补了一圈0 </p>
<p>ZeroPadding2D((1,1)</p>
<p>这个函数是指在横向和纵向，即四周都补0</p>
<p>接着是卷积层。有64个(3,3)的卷积核，激活函数是relu ,</p>
<p>model.add(Convolution2D(64, 3, 3, activation=’relu’))</p>
<p>一个卷积核扫完图片，生成一个新的矩阵，64个就生成64 层。</p>
<p>接着是补0，接着再来一次卷积。此时图像数据是64<em>224</em>224</p>
<p>model.add(ZeroPadding2D((1,1)))</p>
<p>model.add(Convolution2D(64, 3, 3, activation=’relu’))</p>
<p>接着是池化，小矩阵是(2,2) ，步长(2,2),指的是横向每次移动2格，纵向每次移动2格。</p>
<p>model.add(MaxPooling2D((2,2), strides=(2,2)))</p>
<p>按照这样池化之后，数据变成了64<em>112</em>112，矩阵的宽高由原来的224减半，变成了112</p>
<p>再往下，同理，只不过是卷积核个数依次变成128，256，512，而每次按照这样池化之后，矩阵都要缩小一半。</p>
<p>13层卷积和池化之后，数据变成了 512<em>7</em>7 </p>
<p>然后Flatten()，将数据拉平成向量，变成一维512<em>7</em>7=25088</p>
<p>接着是3个全连接层</p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180715/322c7459926140c69be4b12c9a845daa.jpeg" alt="img"></p>
<p>这里很少有人解释为什么全连接层里有4096 个神经元，其他数行不行？</p>
<p>其实这里4096只是个经验值，其他数当然可以，试试效果，只要不要小于要预测的类别数，这里要预测的类别有1000种，所以最后预测的全连接有1000个神经元。如果你想用VGG16 给自己的数据作分类任务，这里就需要改成你预测的类别数。</p>
<p>至此VGG16整个网络架构以及数据变化都清楚了。</p>
<p>如果要设计其他类型的CNN网络，就是将这些基本单元比如卷积层个数、全连接个数按自己需要搭配变换，是不是很简单？</p>
<p>下面我们再来解释一下VGG16里面参数个数如何变化</p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180715/02abff950f5f43f4b98b20dbd3fc83b6.jpeg" alt="img"></p>
<p>这里主要看两列数据，一个是memory , 表示的是数据流变化。</p>
<p>一个是weights 表示的是参数变化。作卷积的时候才有参数，即卷积核内的值。全连接的神经元也有参数，一个神经元包含一个权重值。</p>
<p>刚开始是彩色图像3层色值通道，每层64个 (3,3) 的卷积核，所以参数个数是3<em>64</em>3*3</p>
<p>第一次卷积之后，数据变成64* 224<em>224，即有64层宽224，高224的矩阵数据，再次卷积时，还是每层64个 (3,3) 的卷积核，参数个数变成64</em>64<em>3</em>3，往下都是以此类推。</p>
<p>我们看到参数个数最多时达到1600万个，要是更大的图片参数会更多，普通计算机要训练这么庞大的参数会很卡，所以很多人做深度学习的就要求配置GPU 来提高训练速度。</p>
<p><strong>下面用VGG16 来做一个图像识别案例：</strong></p>
<p><strong>完整代码地址：</strong></p>
<p>VGG16 是基于大量真实图像的 ImageNet 图像库预训练的网络</p>
<p>vgg16对应的供keras使用的模型人家已经帮我们训练好，我们将学习好的 VGG16 的权重迁移（transfer）到自己的卷积神经网络上作为网络的初始权重，这样我们自己的网络不用从头开始从大量的数据里面训练，从而提高训练速度。这里的迁移就是平时所说的迁移学习。</p>
<p>对应的模型已经下载好来，可以通过上面的方式获取。</p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180715/f4d81d07100446b992307b8b77163ca5.jpeg" alt="img"></p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180715/c3194a9f29ff4c3f8fc6f56621f611a3.jpeg" alt="img"></p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180715/14c14d9603324e1f9b4c4ac9387458a4.jpeg" alt="img"></p>
<p>预测2</p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180715/fd4c84fd69954c1296da2193d9145368.jpeg" alt="img"></p>
<p>预测3</p>
<p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180715/f385f9cafc3e4d30a50ae5a823c4a80f.jpeg" alt="img"></p>
<p>准确率还是不错的！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/24/python爬取网页所有链接/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/24/python爬取网页所有链接/" itemprop="url">python爬取网页所有链接</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-24T10:11:33+08:00">
                2019-09-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。<br>本文链接：<a href="https://blog.csdn.net/qq_36369941/article/details/88411464" target="_blank" rel="noopener">https://blog.csdn.net/qq_36369941/article/details/88411464</a><br>python3 实现爬取网站下所有URL</p>
<p>获取首页元素信息：<br>首页的URL链接获取：<br>遍历第一次返回的结果：<br>递归循环遍历：<br>全部代码如下：<br>小结：<br>python3.6<br>requests &amp;&amp; bs4<br>采用递归方法，最终爬取网站所有链接<br>获取首页元素信息：</p>
<p>目标 test_URL：<a href="http://www.xxx.com.cn/" target="_blank" rel="noopener">http://www.xxx.com.cn/</a><br>首先检查元素，a 标签下是我们需要爬取得链接，通过获取链接路径，定位出我们需要的信息</p>
<p>soup = Bs4(reaponse.text, “lxml”)<br>urls_li = soup.select(“#mainmenu_top &gt; div &gt; div &gt; ul &gt; li”)<br>1<br>2</p>
<p>首页的URL链接获取：</p>
<p>完成首页的URL链接获取，具体代码如下：</p>
<p>def get_first_url():<br>    list_href = []<br>    reaponse = requests.get(“<a href="http://www.xxx.com.cn&quot;" target="_blank" rel="noopener">http://www.xxx.com.cn&quot;</a>, headers=headers)<br>    soup = Bs4(reaponse.text, “lxml”)<br>    urls_li = soup.select(“#mainmenu_top &gt; div &gt; div &gt; ul &gt; li”)<br>    for url_li in urls_li:<br>        urls = url_li.select(“a”)<br>        for url in urls:<br>            url_href = url.get(“href”)<br>            list_href.append(head_url+url_href)<br>            out_url = list(set(list_href))<br>    for reg in out_url:<br>        print(reg)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>演示结果如下：</p>
<p>遍历第一次返回的结果：</p>
<p>从第二步获取URL的基础上，遍历请求每个页面，获取页面中的URL链接，过滤掉不需要的信息<br>具体代码如下：</p>
<p>def get_next_url(urllist):<br>    url_list = []<br>    for url in urllist:<br>        response = requests.get(url,headers=headers)<br>        soup = Bs4(response.text,”lxml”)<br>        urls = soup.find_all(“a”)<br>        if urls:<br>            for url2 in urls:<br>                url2_1 = url2.get(“href”)<br>                if url2_1:<br>                    if url2_1[0] == “/“:<br>                        url2_1 = head_url + url2_1<br>                        url_list.append(url2_1)<br>                        if url2_1[0:24] == “<a href="http://www.xxx.com.cn&quot;" target="_blank" rel="noopener">http://www.xxx.com.cn&quot;</a>:<br>                            url2_1 = url2_1<br>                            url_list.append(url2_1)<br>                        else:<br>                            pass<br>                    else:<br>                        pass<br>                else:<br>                    pass<br>        else:<br>            pass<br>    url_list2 = set(url_list)<br>    for url_ in url_list2:<br>        res = requests.get(url_)<br>        if res.status_code ==200:<br>            print(url_)<br>    print(len(url_list2))<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>递归循环遍历：</p>
<p>递归实现爬取所有url，在get_next_url()函数中调用自身，代码如下：</p>
<p>get_next_url(url_list2)<br>1<br>全部代码如下：</p>
<p>#!/usr/bin/env python </p>
<h1 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title="-- coding:utf-8 --"></a>-<em>- coding:utf-8 -</em>-</h1><p>import requests<br>from bs4 import BeautifulSoup as Bs4</p>
<p>head_url = “<a href="http://www.xxx.com.cn&quot;" target="_blank" rel="noopener">http://www.xxx.com.cn&quot;</a><br>headers = {<br>    “User-Agent”: “Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36”<br>}<br>def get_first_url():<br>    list_href = []<br>    reaponse = requests.get(head_url, headers=headers)<br>    soup = Bs4(reaponse.text, “lxml”)<br>    urls_li = soup.select(“#mainmenu_top &gt; div &gt; div &gt; ul &gt; li”)<br>    for url_li in urls_li:<br>        urls = url_li.select(“a”)<br>        for url in urls:<br>            url_href = url.get(“href”)<br>            list_href.append(head_url+url_href)<br>            out_url = list(set(list_href))<br>    return out_url</p>
<p>def get_next_url(urllist):<br>    url_list = []<br>    for url in urllist:<br>        response = requests.get(url,headers=headers)<br>        soup = Bs4(response.text,”lxml”)<br>        urls = soup.find_all(“a”)<br>        if urls:<br>            for url2 in urls:<br>                url2_1 = url2.get(“href”)<br>                if url2_1:<br>                    if url2_1[0] == “/“:<br>                        url2_1 = head_url + url2_1<br>                        url_list.append(url2_1)<br>                        if url2_1[0:24] == “<a href="http://www.xxx.com.cn&quot;" target="_blank" rel="noopener">http://www.xxx.com.cn&quot;</a>:<br>                            url2_1 = url2_1<br>                            url_list.append(url2_1)<br>                        else:<br>                            pass<br>                    else:<br>                        pass<br>                else:<br>                    pass<br>        else:<br>            pass<br>    url_list2 = set(url_list)<br>    for url_ in url_list2:<br>        res = requests.get(url_)<br>        if res.status_code ==200:<br>            print(url_)<br>    print(len(url_list2))<br>    get_next_url(url_list2)</p>
<p>if <strong>name</strong> == “<strong>main</strong>“:<br>    urllist = get_first_url()<br>    get_next_url(urllist)<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>小结：</p>
<p>刚开始学习写python脚本，有不足之处，多多指导，有一个小bug,后期会进一步完善。<br>————————————————<br>版权声明：本文为CSDN博主「淡淡的就好_」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_36369941/article/details/88411464" target="_blank" rel="noopener">https://blog.csdn.net/qq_36369941/article/details/88411464</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/24/python中的request模块/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/24/python中的request模块/" itemprop="url">python中的request模块</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-24T09:53:20+08:00">
                2019-09-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文转自：<a href="https://www.cnblogs.com/ydy11/p/8902631.html（版权归属原作者，因觉得写得非常好，故引用）" target="_blank" rel="noopener">https://www.cnblogs.com/ydy11/p/8902631.html（版权归属原作者，因觉得写得非常好，故引用）</a></p>
<h2 id="python模块之request模块的理解"><a href="#python模块之request模块的理解" class="headerlink" title="python模块之request模块的理解"></a><a href="https://www.cnblogs.com/ydy11/p/8902631.html" target="_blank" rel="noopener">python模块之request模块的理解</a></h2><p>​       request模块是一个用于访问网络的模块，</p>
<p>1、不管写什么样的脚本我们都知道首先要导入我们所需要的模块</p>
<p> <img src="http://images2018.cnblogs.com/blog/1254882/201804/1254882-20180421181412941-467796016.png" alt="img"></p>
<p>2、既然这个模块是访问网络的模块我们就给他传递一个url，发送get请求。</p>
<p>因为在做ctf题目，所以就已题目的url为例</p>
<p><img src="http://images2018.cnblogs.com/blog/1254882/201804/1254882-20180422083000000-921523427.png" alt="img"></p>
<p>发送后，我们会得到这个相应对象re，里面就是我们想要的相应信息。这里如果不做任何处理输出的话会返回请求的状态码，如果希望出现内容，需要添加.text。以字符串格式输出。同理post传递也是一样的。</p>
<p>3、发送带参数的请求</p>
<p>get请求：发送get请求时，他的参数是params为关键字传递的。我们来测试一下</p>
<p><img src="http://images2018.cnblogs.com/blog/1254882/201804/1254882-20180422093907557-1207932257.png" alt="img"></p>
<p>post请求：发送post请求时，以data为关键字参数来传递的，测试一下</p>
<p><img src="http://images2018.cnblogs.com/blog/1254882/201804/1254882-20180422094222197-1220305938.png" alt="img"></p>
<p>4、获取响应头中的某个字段</p>
<p>这个我们可以利用headers，测试一下</p>
<p>获取全部字段</p>
<p><img src="http://images2018.cnblogs.com/blog/1254882/201804/1254882-20180422094619163-568126485.png" alt="img"></p>
<p>获取指定的字段，例如这个题目，我要获取FLAG字段</p>
<p><img src="http://images2018.cnblogs.com/blog/1254882/201804/1254882-20180422094716789-1220605561.png" alt="img"></p>
<p>‘re.headers’获取的是一个字典，我们想要获取某一个，就可以通过这种形式获取。</p>
<p>如果我们想要获得请求头，可以直接re.request.headers，测试一下</p>
<p><img src="http://images2018.cnblogs.com/blog/1254882/201804/1254882-20180422100345717-182671591.png" alt="img"></p>
<p>文章结尾，送上ctf题目的python脚本</p>
<p><img src="1254882-20180422100709657-1367788707.png" alt="img"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/23/谷歌在NASA发表量子霸权文章/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/23/谷歌在NASA发表量子霸权文章/" itemprop="url">谷歌在NASA发表量子霸权文章</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-23T23:13:45+08:00">
                2019-09-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="谷歌实现量子霸权？论文上架被撤回"><a href="#谷歌实现量子霸权？论文上架被撤回" class="headerlink" title="谷歌实现量子霸权？论文上架被撤回"></a>谷歌实现量子霸权？论文上架被撤回</h1><p>量子计算机用3分20秒完成的一项计算，全球最强大的超算Summit要花1万年。</p>
<p>这个成果，来自谷歌最新的量子计算研究，发表在NASA官网上。论文宣布，“量子霸权”实现了。</p>
<p>英国政府的量子技术顾问<strong>Steve Brierley</strong>说：</p>
<p>这是第一次有人证明，量子计算机的性能真的能超过经典计算机。</p>
<p>是个了不起的成就。</p>
<p>另外，美国民主党的总统参选人杨安泽，推特转发了这则，引起强烈关注，一日便有5100人点赞：</p>
<p>大事啊，至少说明，没有什么破解不了的密码了。</p>
<p><img src="http://x0.ifengimg.com/res/2019/67687FF427FA5726DB367E272D3DF2978102DA25_size139_w1080_h891.jpeg" alt="img"></p>
<p>虽然，NASA没过多久便<strong>下架</strong>了这篇论文，但正因如此，人类反而对谷歌新的成果更加好奇了。</p>
<p>一窥论文</p>
<p>NASA匆匆撤下了论文，我们仍然能从网页缓存中一窥论文的内容。</p>
<p>谷歌在论文摘要中说：</p>
<p>我们使用具有53个超导量子位的可编程处理器，占用状态空间为253≈1016。重复实验的测量结果会采样相应的概率分布。</p>
<p>我们使用经典模拟进行验证。虽然我们的处理器大约需要200秒来采样一</p>
<p>百万个量子电路实例，但是一台先进的超级计算机将需要大约1万年的时间来执行等效的任务。</p>
<p>相对于所有已知经典算法而言，这种巨大的提速在实验中实现了计算任务上的量子霸权，并预示了人们期待已久的计算范式的出现。</p>
<p>在摘要中，谷歌揭示了这台量子计算机强大的原因，由于量子力学中物体的状态是在希尔伯特空间中演化，因此只需53个量子位就可以模拟1016种状态，而这个数字已经超出了当今超级计算机的运算能力（一般是等价于50个量子比特）。</p>
<p>主要指出的是谷歌虽然实现了72个量子位的芯片，但这和72位量子计算机是两回事。谷歌Bristlecone芯片是利用9个相同模式的量子比特进行耦合，然后依次扩展出去，并非实现了两两量子比特之间的耦合。</p>
<p>量子计算机的实际应用也面临诸多问题。由于在于0和1两种状态之间的能量差太小，需要降低到绝对零度附近，才能防止被热量所破坏。</p>
<p>此外，粒子之间状态的耦合也有时间限制，时间一长，两个粒子将不再“相干”。在进行量子计算实验时，所有的量子操作要在量子退相干之前完成，才能保证量子操作的保真度（Fidelity），否则运算结果将不再可信。</p>
<p>今年3月，谷歌在一篇论文中给出了如下的量子计算机演化概念图：</p>
<p><img src="http://x0.ifengimg.com/res/2019/C3D992100C6C1095A402B7D5B52AFB78E08179B0_size17_w624_h271.jpeg" alt="img"></p>
<p>这张图显示了量子计算错误率和量子比特数之间的关系。谷歌量子人工智能实验室的预期研究方向为图中红色曲线，他们希望通过建立纠错量子计算机，降低错误率，从而将这项技术推入右下角的绿色可用区域。</p>
<p>什么是量子霸权</p>
<p><strong>量子霸权</strong>，也叫<strong>量子优势</strong>，即在未来的某个时刻，功能强大的量子计算机可以完成经典计算机几乎不可能完成的任务。</p>
<p>比如在一天之内破解原本几万年才能破解的密码、实现通用人工智能、快速模拟分子模型。</p>
<p>提出这一假想的原因是，量子计算机的发展似乎遵循着<strong>“内文定律”</strong>，而经典计算机遵循着“摩尔定律”。</p>
<p><img src="http://x0.ifengimg.com/res/2019/90DEA82D121027B96EF4ACEFD6E90660B879B9B3_size78_w1080_h718.jpeg" alt="img"></p>
<p><strong>△</strong></p>
<p>提出内文定律的Hartmut Neven</p>
<p>摩尔定律为大众所熟知，即计算机芯片的晶体管密度每18个月翻一番，算力增强一倍，这是一种指数增长的规律。但是近年来随着晶体管的尺寸逐渐逼近物理学极限，这一定律已经放缓甚至失效。</p>
<p>而来自谷歌量子人工智能实验室的负责人Hartmut Neven认为，量子计算机的速度正在以双指数的速度增长。双指数是指数之上再加一层指数，形式如下：</p>
<p>Neven认为，量子计算机比经典计算机存在着两个指数优势：</p>
<p>首先，量子位相比普通位具有效率优势，如果一个量子电路具有4个量子位，那么需要一个具有16个普通位的经典电路才能实现等效的计算能力。</p>
<p>其次，量子芯片也在快速改进。谷歌量子芯片正在以指数级的速度发展，这种快速的改善是由于量子电路中错误率的降低。而降低错误率能帮助我们构建更大的量子芯片。</p>
<p>双指数的增长速度远远快于指数函数，因此谷歌认为虽然量子计算机速度现在远不及经典计算机，但是总有一天会超过后者。</p>
<p><img src="http://x0.ifengimg.com/res/2019/9C33162FFB94A0BA4650B7DD8BDB80CA27FFA9F9_size4_w500_h500.png" alt="img"></p>
<p>这可不仅仅是谷歌研究人员的自卖自夸，实际上谷歌实验室也是按照双指数规律的速度在推进着：去年12月，一台笔记本电脑即可模拟谷歌最好的量子计算机；到了今年1月，一台功能强大的台式机才可与之媲美；而到了今年2月，经典计算机的速度已经不能和量子计算机匹敌，无法再模拟后者了。</p>
<p>为何由NASA发布</p>
<p>也许你会好奇，谷歌的论文为何要在NASA官网上发布。其实谷歌去年就已经和NASA展开合作，并且立下了flag：要在今年实现所谓量子霸权，即让量子计算机的运算能力远远超过经典计算机。</p>
<p>2018年7月，谷歌宣布与NASA建立合作伙伴关系，计划将量子计算机上运行的结果，与经典仿真进行比较，实现所谓的“量子霸权”，而且当时的谷歌预测在今年就可以实现。</p>
<p>双方合作使用的量子芯片名字叫做<strong>Bristlecone</strong>，总共包含72个量子比特。由于Bristlecone需要将超导电路维持在绝对零度附近，因此无法将其从谷歌的实验室搬走。NASA研究人员只能通过谷歌的云API远程连接Bristlecone。</p>
<p><img src="http://x0.ifengimg.com/res/2019/24755482CA9C6E198B19DBA4D006C850163C59BC_size41_w1080_h567.jpeg" alt="img"></p>
<p>双方将共同研究如何将“各种各样的优化和采样问题”映射到Bristlecone量子计算系统上。</p>
<p>按照双方的约定，今年年初，他们在NASA最强的超级计算机Pleiades上对运行这些仿真所必需的软件进行编码，并在合同签订后的12个月，即今年7月，比较量子电路仿真和谷歌量子计算机硬件的结果。</p>
<p>虽然谷歌和NASA持非常乐观的态度，但业界也有人这个flag要倒。</p>
<p>阿里巴巴数据基础设施和搜索技术部门的研究人员发表了一篇论文，认为要实现量子霸权可能需要错误率更低的量子芯片。</p>
<p>南加州大学量子信息科学与技术中心主任Daniel Lidar也对此表示怀疑。他接受麻省理工科技评论时说：“（实现量子霸权）似乎还需要其他方式抑制错误。”</p>
<p>如果这篇论文通过了同行评审，则意味着谷歌和NASA的flag没有倒，而且量子计算将进入一个新的时代。</p>
<p>创造历史</p>
<p>几十年来，量子计算这个领域，都笼罩在一个强大的假设之下：</p>
<p>任何其他类型的计算机，能够高效完成的计算，<strong>经典计算机</strong>也都能高效完成。</p>
<p>这个假设，来自“广义邱奇-图灵论题” (Extended Church Turing Thesis) 。</p>
<p>如今，谷歌的量子计算机用<strong>3分20秒</strong>完成的计算，交给全球排名第一的超级计算机Summit，大概需要<strong>1万年</strong>。这就打破了人类曾经的猜想。</p>
<p>谷歌说：</p>
<p>这标志了第一个只能用量子处理器执行的运算。</p>
<p>在通往全面量子计算的路上，这是一个里程碑。</p>
<p>量子机器的算力，将会以双指数速度增长。</p>
<p>当然，这项前所未有的成就，不止是谷歌自家的狂欢。</p>
<p>为英国政府担任量子技术顾问的<strong>Steve Brierley</strong>，已经在领域里工作了20年，还是量子软件初创公司Riverlane的创始人。他强调说：</p>
<p>第一次有人证明，量子计算机的性能真的能超过经典计算机。</p>
<p>这是个了不起的成就。</p>
<p>走到领域之外，美国民主党的总统参选人杨安泽 (Andrew Yang) ，是这样说的：</p>
<p>谷歌达成量子霸权是个大事。先不说别的，这至少意味着，没有不能破解的代码了。</p>
<p>他的这条推特，已经收获了5100赞。</p>
<p>不久之后，杨还补充了一条：</p>
<p>我们的加密技术也得跟上啊。</p>
<p>这条推特，又获得了3200赞。</p>
<p>下一步呢</p>
<p>量子霸权实现了，但故事并没有结束。</p>
<p>在许多人的眼里，量子霸权是一个人为设定的里程碑：只要在任何一项任务上，证明量子计算机超过经典计算机就可以了。</p>
<p>怎样的任务都可以，也就不一定有现实意义。比如，谷歌给量子计算机的任务是：鉴定一个随机数生成器，是不是真的随机。</p>
<p>所以，一个里程碑之后，还有另一个里程碑要赶去。</p>
<p><img src="http://x0.ifengimg.com/res/2019/0B76B06D9C2698CFA8232E5E39E8BD75268241F4_size52_w1080_h720.jpeg" alt="img"></p>
<p>实用性</p>
<p>IBM的量子计算战略负责人Robert Sutor，提到了一个“<strong>量子优势</strong> (Quantum Advantage) ”概念，那是一个实用性的里程碑：</p>
<p>量子优势，是在一个真实应用场景 (比如金融服务、AI、化学里面) ，量子计算机做出了比任何经典计算机要明显优秀的工作。</p>
<p>作为谷歌的对手，IBM一直在探索量子计算的应用，与摩根大通、梅赛德斯奔驰都有这一方面的合作。最近他们还在线上对外开放了一台53比特的通用量子计算机。</p>
<p>IBM说，量子霸权这个词他们并<strong>不用</strong>，也<strong>不在意</strong>。</p>
<p><img src="http://x0.ifengimg.com/res/2019/34D459CD20A4AFE167B111F117BEB11A0AAA00E2_size1429_w600_h600.gif" alt="img"></p>
<p>不过，谷歌研究院、加州理工学院的理论物理学家Fernando Brandão相信：</p>
<p>在达成量子霸权之前，量子计算机不可能做出什么有意思的事。</p>
<p>现在，就算量子计算机做的任务还没有实际意义，研究人员还是可以从中学到经验，今后开发出更有用的量子计算机。</p>
<p>2018年，波士顿咨询公司 (BCG) 发布的报告说，量子计算机可以改变许多领域的游戏规则：</p>
<p>比如<strong>密码学</strong>和化学，对化学的影响会广泛波及材料学，以及农业和制药等等领域。</p>
<p>人工智能，机器学习就更不用说了。</p>
<p>另外，物流，制造，金融，能源……也都会出现新的应用。</p>
<p>这个未来，整个世界都在期待着。</p>
<p>容错率</p>
<p>再下一个里程碑，就是造出一台容错的量子计算机。</p>
<p><img src="http://x0.ifengimg.com/res/2019/5E2807E1FE99C40B3B11E7AC5304E541DCB15A9A_size6_w275_h183.jpeg" alt="img"></p>
<p>这样的计算机，能在一项计算当中实时纠正错误，原则上可以实现无错的量子计算。</p>
<p>目前，主流的方法叫做“Surface Code”，每个执行计算的“逻辑”量子比特，都要有成千上万个纠错量子比特来支持。</p>
<p>这远远超出了当前量子计算的最强算力。</p>
<p>所以，量子计算到底需不需要容错能力，也是值得讨论的问题。</p>
<p>来自谷歌的Fernando Brandão说：</p>
<p>有许多思路可走，但没有哪个方向是确定的。</p>
<p>不过，在走向未来之前，关于这项研究，还有一个直击灵魂的问题：</p>
<p>如果说，超算要1万年才能算好，怎么才能知道量子计算机得出的结果是对的呢？</p>
<p>转载原文地址<a href="http://tech.ifeng.com/c/7qAzAL19DSc" target="_blank" rel="noopener">http://tech.ifeng.com/c/7qAzAL19DSc</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
